<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>13.3. Unit Testing in Action &#8212; Introduction to Professional Web Development in JavaScript  documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/fa/css/all.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/launchcode.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/site.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="13.4. Test-Driven Development" href="tdd.html" />
    <link rel="prev" title="13.2. Hello, Jasmine!" href="hello-jasmine.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body class="body-bc">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/lc-ed-logo.png" alt="LaunchCode logo"></span>
        </a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
    <label for="q" class="searchLabel">Search</label>
    <input type="text" name="q" class="form-control" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<ol class="breadcrumb container">
    <li><a href="../../index.html">Contents</a></li>
    <li><a href="index.html">13. Unit Testing</a></li>
    <li class="active">13.3. Unit Testing in Action</li>
</ol>



<div class="container">
  <div class="row">
    <div class="col-md-10 col-md-offset-1 content ">

    
  <div class="section" id="unit-testing-in-action">
<h1>13.3. Unit Testing in Action<a class="headerlink" href="#unit-testing-in-action" title="Permalink to this headline">¶</a></h1>
<p id="index-0">Testing is a bit of an art; there are no hard and fast rules about how to go about writing good tests. That said, there are some general principles that you should follow. In this section, we explore some of these.</p>
<p>In particular, we focus on identifying good <strong>test cases</strong> by working through a specific example. A test case is a single situation that is being tested.</p>
<div class="section" id="what-to-test">
<h2>13.3.1. What to Test<a class="headerlink" href="#what-to-test" title="Permalink to this headline">¶</a></h2>
<p>When writing tests for your code, what should you test? You can’t test <em>every</em> possible situation or input. But you also don’t want to leave out important cases. A function or program that isn’t well-tested might have bugs lurking beneath the surface.</p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-sticky-note" aria-hidden="true"></i>Note</p>
<p class="last">Since we are focused on <em>unit</em> testing, in this chapter we will generally use the term “unit” to refer to the function or program under consideration.</p>
</div>
<p>Regardless of the situation, there are two types of test cases that you should consider: positive/negative tests and edge cases.</p>
<p>A <strong>positive test</strong> is a test case that gives the unit valid data, or, in the case of boolean functions, data that should result in a return value of <code class="docutils literal notranslate"><span class="pre">true</span></code>. A <strong>negative test</strong> gives the unit <em>invalid</em> data, or data that should result in a return value of <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>An <strong>edge case</strong> is a test case that provides input at the extreme edge of what the unit should be able to handle. For example, if a function should work for input values between 0 and 100 then we should test not just values like 5, 50, and 75, but also 0 and 100. These values are at the literal <em>edge</em> of acceptable input values. Depending on the behavior function, we may also want to include a negative test with values -1 and 101.</p>
<div class="admonition-example admonition">
<p class="first admonition-title"><i class="fas fa-binoculars" aria-hidden="true"></i>Example</p>
<p>Suppose a program has a collection of addresses for houses within a given city. It has a function, <code class="docutils literal notranslate"><span class="pre">getNeighbors</span></code>, that will return the immediate neighbors of a given address (those addresses on either side adjacent to the given address).</p>
<p class="last">Edge cases for this program would include houses on a corner, houses adjacent to a property with no address (for example, a park), and houses in the middle of a block with an alley on one side.</p>
</div>
<p>Considering postive, negetive, and edge tests will go a long way toward helping you create well-tested code.</p>
<p>Let’s see these in action, by writing tests for <a class="reference internal" href="../functions/composing-functions.html#palindrome-function"><span class="std std-ref">our isPalindrome function</span></a>.</p>
</div>
<div class="section" id="setting-up">
<h2>13.3.2. Setting Up<a class="headerlink" href="#setting-up" title="Permalink to this headline">¶</a></h2>
<p>Here’s the function we want to test:</p>
<div class="highlight-js notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">str</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">isPalindrome</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">===</span> <span class="nx">str</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="repl-link"><a class="reference external" href="https://repl.it/&#64;launchcode/isPalindrome" target="_blank">repl.it<i class="fas fa-external-link-alt" aria-hidden="true"></i></a></p>
<p>Code along with us by forking <a class="reference external" href="https://repl.it/&#64;launchcode/isPalindrome-With-Tests-Starter" target="_blank">our repl.it starter code project<i class="fas fa-external-link-alt" aria-hidden="true"></i></a>, which includes the above code in <code class="docutils literal notranslate"><span class="pre">palindrome.js</span></code> and the Jasmine test runner code in <code class="docutils literal notranslate"><span class="pre">index.js</span></code>. Note that we have removed the <code class="docutils literal notranslate"><span class="pre">console.log</span></code> statements from the original code and exported the <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code> function:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">isPalindrome</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-lightbulb" aria-hidden="true"></i>Tip</p>
<p class="last">When creating a unit-tested project, <em>always</em> start by copying the Jasmine test runner code into <code class="docutils literal notranslate"><span class="pre">index.js</span></code> and putting the code you want to test in an appropriately named <code class="docutils literal notranslate"><span class="pre">.js</span></code> file.</p>
</div>
<p>You have become used to testing your code by running it and printint output with <code class="docutils literal notranslate"><span class="pre">console.log</span></code>. When writing unit-tested code, we no longer need to take this approach.</p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-lightbulb" aria-hidden="true"></i>Tip</p>
<p class="last">If you find yourself tempted to add a <code class="docutils literal notranslate"><span class="pre">console.log</span></code> statement to your code, write a unit test instead! You would mostly likely remove that <code class="docutils literal notranslate"><span class="pre">console.log</span></code> after getting your code to work, while the test will remain for you and other developers to use in the future.</p>
</div>
<p>Finally, create <code class="docutils literal notranslate"><span class="pre">spec/</span></code> and add a spec file, <code class="docutils literal notranslate"><span class="pre">palindrome.spec.js</span></code>. This file should include imports and a describe block:</p>
<div class="highlight-js notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">isPalindrome</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;../palindrome.js&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">assert</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;assert&#39;</span><span class="p">);</span>

<span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;isPalindrome&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>

   <span class="c1">// TODO - write some tests!</span>

<span class="p">});</span>
</pre></div>
</td></tr></table></div>
<p>Okay, let’s write some tests!</p>
</div>
<div class="section" id="positive-and-negative-test-cases">
<h2>13.3.3. Positive and Negative Test Cases<a class="headerlink" href="#positive-and-negative-test-cases" title="Permalink to this headline">¶</a></h2>
<div class="section" id="positve-test-cases">
<h3>13.3.3.1. Positve Test Cases<a class="headerlink" href="#positve-test-cases" title="Permalink to this headline">¶</a></h3>
<p>We’ll start with positive and negative tests. For <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code>, some positive tests have inputs:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;aaaa&quot;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;aba&quot;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;racecar&quot;</span></code></li>
</ul>
<p>Calling <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code> with these inputs should return <code class="docutils literal notranslate"><span class="pre">true</span></code> in each case. Notice that these tests are a simple as possible. Keeping test inputs simple, while still covering your desired test cases, will make it easier to fix a but in the event that a unit test failes.</p>
<p>Let’s add tests for these inputs to <code class="docutils literal notranslate"><span class="pre">spec/palindrome.spec.js</span></code>:</p>
<div class="highlight-js notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">isPalindrome</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;../palindrome.js&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">assert</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;assert&#39;</span><span class="p">);</span>

<span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;isPalindrome&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>

   <span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should return true for a single letter&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">isPalindrome</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
   <span class="p">});</span>

   <span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should return true for a single letter repeated&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">isPalindrome</span><span class="p">(</span><span class="s2">&quot;aaa&quot;</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
   <span class="p">});</span>

   <span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should return true for a simple palindrome&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">isPalindrome</span><span class="p">(</span><span class="s2">&quot;aba&quot;</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
   <span class="p">});</span>

   <span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should return true for a longer palindrome&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">isPalindrome</span><span class="p">(</span><span class="s2">&quot;racecar&quot;</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
   <span class="p">});</span>

<span class="p">});</span>
</pre></div>
</td></tr></table></div>
<p>Note the clear test case descriptions (for example, “should return true for a single letter repeated”), which will help us easily identify the expected behavior of our code later.</p>
<p>After adding the positive tests to your file, run them to make sure they all pass.</p>
</div>
<div class="section" id="negative-test-cases">
<h3>13.3.3.2. Negative Test Cases<a class="headerlink" href="#negative-test-cases" title="Permalink to this headline">¶</a></h3>
<p>For <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code>, some negative tests have inputs:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;ab&quot;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;launchcode&quot;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;abA&quot;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;so</span> <span class="pre">many</span> <span class="pre">dynamos&quot;</span></code></li>
</ul>
<p>Calling <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code> with these inputs should return <code class="docutils literal notranslate"><span class="pre">false</span></code> in each case. The last two of these negative tests deserve a bit more discussion.</p>
<p>When writing our <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code> function initially, we made two important decisions:</p>
<ul class="simple">
<li>Case should be considered, and</li>
<li>whitespace should be considered.</li>
</ul>
<p>The definition of a palindrome differs sometimes on these two matters, so it’s important to test them.</p>
<p>Testing with input <code class="docutils literal notranslate"><span class="pre">&quot;abA&quot;`</span></code> ensures that case is considered, since the lowercase version of this string, <code class="docutils literal notranslate"><span class="pre">&quot;aba&quot;</span></code>, <em>is</em> a palindrome. Testing with <code class="docutils literal notranslate"><span class="pre">&quot;so</span> <span class="pre">many</span> <span class="pre">dynamos&quot;</span></code> ensures that whitespace is considered, since the version of this string with whitespace removed, <code class="docutils literal notranslate"><span class="pre">&quot;somanydynamos&quot;</span></code>, <em>is</em> a palindrome.</p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-sticky-note" aria-hidden="true"></i>Note</p>
<p class="last">It’s important to isolate your test cases. For example, <code class="docutils literal notranslate"><span class="pre">&quot;So</span> <span class="pre">Many</span> <span class="pre">Dynamos&quot;</span></code> is a poor choice of input for a negative test, since it contains <em>two</em> characteristics that are being tested for, case and the presence of whitespace. If a test with this input failed, it would NOT be clear why it failed.</p>
</div>
<p>Including specific tests that demonstrate how <em>our</em> <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code> function behaves in these situations helps make our code <em>self-documenting</em>. Someone can read our tests and easily see that we <em>do</em> consider case and whitespace.</p>
<p>Let’s add some test for these negative cases. Add these within the <code class="docutils literal notranslate"><span class="pre">describe</span></code> call.</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should return false for a longer non-palindrome&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
   <span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">isPalindrome</span><span class="p">(</span><span class="s2">&quot;launchcode&quot;</span><span class="p">),</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should return false for a simple non-palindrome&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
   <span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">isPalindrome</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">),</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should be case-sensitive&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
   <span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">isPalindrome</span><span class="p">(</span><span class="s2">&quot;abA&quot;</span><span class="p">),</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should consider whitespace&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
   <span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">isPalindrome</span><span class="p">(</span><span class="s2">&quot;so many dynamos&quot;</span><span class="p">),</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Now run the tests to make sure they pass. Your code now includes a set of tests that considers a wide variety of positive and negative cases.</p>
</div>
</div>
<div class="section" id="edge-cases">
<h2>13.3.4. Edge Cases<a class="headerlink" href="#edge-cases" title="Permalink to this headline">¶</a></h2>
<p>Recall our definition of <strong>edge case</strong>:</p>
<blockquote class="pull-quote">
<div>An edge case is a test case that provides input at the extreme edge of what the unit should be able to handle.</div></blockquote>
<p>Edge cases can look very different for different units of code. Most of the examples we provided above dealt with numerical edge cases. However, edge cases can also be non-numeric.</p>
<p>In the case of <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code>, the most obvious edge case would be that of the empty string, <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>. This is the smallest possible string that we can use when calling <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code>. Not only is it the smallest, but it is essentially <em>different</em> from the next longest string, <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code>—one has characters and one doesn’t.</p>
<p>Should the empty string be considered a palindrome? That decision is up to us, the programmer, and there is not right or wrong answer. In our case, we have decided to take a very literal definition of the term “palindrome” by considering case and whitespace. In other words, our definition says that a string is a palindrome exactly when it equals its reverse. Since the reverse of <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> is also <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, it makes sense to consider the emtpy string a palindrome.</p>
<p>Let’s add this test case to our spec:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should consider the empty string a palindrome&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
   <span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">isPalindrome</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Now run the tests, which should all pass.</p>
<p>You might think that another edge case is that of the longest possible palindrome. Such a palindrome would be as long as the longest possible string in JavaScript. This case is not worth considering for a couple of reasons:</p>
<ul class="simple">
<li>The length of the longest string <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description" target="_blank">can vary across different JavaScript implementations<i class="fas fa-external-link-alt" aria-hidden="true"></i></a>.</li>
<li>The most recent JavaScript specification, ES2016, states that the maximum allowed length of a string should be 2 <sup>53</sup> - 1 characters. This is a LOT of characters, and it is unrealistic to expect that our function will ever be given such a string.</li>
</ul>
</div>
<div class="section" id="toward-a-better-testing-workflow">
<h2>13.3.5. Toward a Better Testing Workflow<a class="headerlink" href="#toward-a-better-testing-workflow" title="Permalink to this headline">¶</a></h2>
<p>In this case, we had a well-written function to write tests for, so it was straightforward to create tests that pass. Most situations will not be this simple. You will often find yourself writing tests for code only to discover a bug, forcing you to go back and update your code. That’s okay! This is precisely what tests are for.</p>
<p>The workflow for this situation is:</p>
<ol class="arabic simple">
<li>Write code</li>
<li>Write tests</li>
<li>Fix any bugs found while testing</li>
</ol>
<p>The rest of the chapter focuses on a programming technique that allows you to completly <em>eliminate</em> the third step, by reversing the order of the first two:</p>
<ol class="arabic simple">
<li>Write tests</li>
<li>Write code</li>
</ol>
<p>As you will soon learn, writing your tests <em>before</em> writing your code is a great way to enhance your programming efficiency and quality.</p>
</div>
</div>



    
    <nav aria-label="Next and Previous Pages">
      <ul class="pager">
        
        <li class="previous"><a href="hello-jasmine.html"><span aria-hidden="true">&larr;</span> 13.2. Hello, Jasmine!</a></li>
        
        
        <li class="next"><a href="tdd.html">13.4. Test-Driven Development <span aria-hidden="true">&rarr;</span></a></li>
        
      </ul>
    </nav>
    
    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
    </p>
  </div>
</footer>
  </body>
</html>